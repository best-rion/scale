<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>SCALE</title>
  <style>
    *{padding: 0;margin: 0;box-sizing: border-box;}
    html {
      overflow: hidden;
      overscroll-behavior: none;
    }
    body {
      margin: 40px;
      padding: 0;
      display: flex;
      justify-content: center; /* center horizontally */
      background: #f2f2f2;
    }

    .container {
      width: 960px; /* strict width */
    }

    .header {
      display: flex;
      justify-content: space-between; /* left stays left, right stays right */
      align-items: flex-start;
      margin-bottom: 10px;
    }

    .header-left {
      display: flex;
      flex-direction: column;
      align-items: flex-start; /* align left */
      gap: 10px;
    }

    .header-right {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: flex-start; /* right aligned */
    }

    canvas {
      display: block;
      margin-top: 12px;
      border: 1px solid #888;
      background: #fff;
      cursor: crosshair;
      width: 960px; /* strict width */
      height: 1300px; /* strict height */
    }

    /* Inputs & buttons */

    input[type="file"],
    input[type="number"],
    button {
      font-size: 24px;
      padding: 12px 20px;
      border: 1px solid #bbb;
      border-radius: 4px;
      background: #fff;
      color: #222;
    }

    input[type="number"] {
      width: auto;
    }

    button {
      cursor: pointer;
    }

    button:hover {
      background: #eaeaea;
    }

    /* Mode buttons */

    #modeButton-container {
      display: flex;
      gap: 6px;
    }

    .modeButton {
      min-width: 60px;
    }

    /* Instruction */

    #instruction {
      margin: 0;
      font-size: 36px;
      color: #777;
      min-height: 18px; /* prevents layout jump */
    }

    /* Result */

    #result-container {
      font-size: 36px;
      font-weight: 500;
      min-height: 20px;
    }

    #result-label {
      color: #555;
    }

    #touchMode-container {
      display: flex;
      justify-content: center;
    }
  </style>
</head>

<body>
<div class="container">
  <div class="header">
    <div class="header-left">
      <input type="file" id="imgUpload" accept="image/*">
      <div id="modeButton-container" style="display: none">
        <button class="modeButton" id="length" onclick="setLengthMode()">Length</button>
        <button class="modeButton" id="radius" onclick="setRadiusMode()">Radius</button>
        <button class="modeButton" id="angle" onclick="setAngleMode()">Angle</button>
      </div>
      <p id="result-container" style="display: none;">
        <span id="result-label"></span>: <span id="result-value"></span>
      </p>
    </div>

    <div class="header-right">
      <p id="instruction"></p>
      <input type="number" id="unit" placeholder="length of the reference line" style="display: none" onclick="unitValueUpdate()">
      <button id="reset-button" style="display: none" onclick="redrawReferenceLine()">Redraw Reference Line</button>
    </div>
  </div>
  <div id="touchMode-container">
    <button id="zoom" class="touch-mode" style="color:red;" onclick="setTouchModeZoom()">Zoom/Move</button>
    <button id="point" class="touch-mode" onclick="setTouchModePoint()">Add Point</button>
  </div>

  <canvas id="canvas" width="960" height="1300" style="touch-action: none;"></canvas>
</div>

<script>
  const canvas = document.getElementById('canvas');
  const unitInputElement = document.getElementById('unit');
  unitInputElement.value = null;
  unitInputElement.addEventListener('input', () => {
    unitValueUpdate();
  })
  const resetButtonElement = document.getElementById('reset-button');
  const resultValueElement = document.getElementById('result-value');
  const resultLabelElement = document.getElementById('result-label');
  const resultContainerElement = document.getElementById('result-container');

  let touchMode = "zoom";
  let unitValueAvailable = false;
  const DRAW_REF_LINE_INST= "Draw Reference Line";
  const ctx = canvas.getContext('2d');
  let img = new Image();
  let imgLoaded = false;

  let mousePosition = { x: 0, y: 0 };

  // Image state
  let imgX = 0, imgY = 0;
  let scale = 1;
  let dragStart = { x: 0, y: 0 };

  // For unit
  let referencePoint1Selected = false;
  let referencePoint2Selected = false;
  let referencePoints = {x1: 0, y1: 0, x2: 0, y2: 0};
  let unitLength = 0;

  // For line
  let linePoint1Selected = false;
  let linePoint2Selected = false;
  let linePoints = {x1: 0, y1: 0, x2: 0, y2: 0};

  // For curvature
  let circlePoint1Selected = false;
  let circlePoint2Selected = false;
  let circlePoint3Selected = false;
  let circlePoints = {x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0};
  let circleCenterPoint = {x: 0, y: 0};
  let circleRadius = 0;

  // For angle
  let anglePoint1Selected = false;
  let anglePoint2Selected = false;
  let anglePoint3Selected = false;
  let anglePoints = {x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0};

  let mode;
  const setLengthMode = () => {
    mode = "length";
    document.getElementById("length").style.color = "red";
    document.getElementById("radius").style.color = "black";
    document.getElementById("angle").style.color = "black";
    showUnitInstruction();
    resetRadius();
    resetAngle();
    scheduleDraw();
  }
  const setRadiusMode = () => {
    mode = "radius";
    document.getElementById("length").style.color = "black";
    document.getElementById("radius").style.color = "red";
    document.getElementById("angle").style.color = "black";
    showUnitInstruction();
    resetLength();
    resetAngle();
    scheduleDraw();
  }
  const setAngleMode = () => {
    mode = "angle";
    document.getElementById("length").style.color = "black";
    document.getElementById("radius").style.color = "black";
    document.getElementById("angle").style.color = "red";
    hideUnitInstruction();
    resetLength();
    resetRadius();
    if (referencePoint1Selected && !referencePoint2Selected) {
      referencePoint1Selected = false;
    }
    scheduleDraw();
  }
  const showUnitInstruction = () => {
    if (!referencePoint2Selected) {
      document.getElementById("instruction").innerText = DRAW_REF_LINE_INST;
    }
  }
  const hideUnitInstruction = () => {
    document.getElementById("instruction").innerText = "";
  }
  const recalculate = () => {
    if (mode === "length" && linePoint2Selected) {
      calculateLength();
    }
    if (mode === "radius" && circlePoint3Selected) {
      calculateCircleCenterAndRadius();
    }
  }

  function unitValueUpdate() {
    const unitValue = unitInputElement.value;
    if (isNaN(unitValue) || unitValue === "") {
      document.getElementById("instruction").innerText = "It is not a number";
      unitValueAvailable = false;
    } else if (unitValue <= 0) {
      document.getElementById("instruction").innerText = "Provide a positive number";
    } else {
      document.getElementById("instruction").innerText = "";
      unitValueAvailable = true;
      recalculate();
    }
  }

  function setTouchModeZoom() {
    touchMode = "zoom";
    document.getElementById("zoom").style.color = "red";
    document.getElementById("point").style.color = "black";
  }
  function setTouchModePoint() {
    touchMode = "point";
    document.getElementById("zoom").style.color = "black";
    document.getElementById("point").style.color = "red";
  }

  // Handle image upload
  document.getElementById('imgUpload').addEventListener('change', e => {
    const file = e.target.files[0];
    if (file) {
      img.src = URL.createObjectURL(file);
      img.onload = () => {
        imgLoaded = true;
        document.getElementById("modeButton-container").style.display = "flex";
        reset();

        imgX = canvas.width / 2 - img.width / 2;
        imgY = canvas.height / 2 - img.height / 2;
        scheduleDraw();
      };
    }
  });

  // ===== TOUCH SUPPORT =====
  let ongoingTouches = [];
  let lastTouchDistance = 0;
  let touchDrag = false;

  function getDistance(touch1, touch2) {
    const dx = touch2.clientX - touch1.clientX;
    const dy = touch2.clientY - touch1.clientY;
    return Math.sqrt(dx*dx + dy*dy);
  }

  // Single-finger drag (move image)
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (!imgLoaded) return;

    if (e.touches.length === 1) {
      touchDrag = true;
      dragStart.x = e.touches[0].clientX - imgX;
      dragStart.y = e.touches[0].clientY - imgY;
    } else if (e.touches.length === 2) {
      // Pinch start
      lastTouchDistance = getDistance(e.touches[0], e.touches[1]);
      touchDrag = false;
    }
  });

  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (!imgLoaded) return;

    if (e.touches.length === 1) {
      if (touchDrag && touchMode === "zoom") {
        imgX = e.touches[0].clientX - dragStart.x;
        imgY = e.touches[0].clientY - dragStart.y;
      }
      const rect = canvas.getBoundingClientRect();
      mousePosition.x = e.touches[0].clientX - rect.left;
      mousePosition.y = e.touches[0].clientY - rect.top;
      scheduleDraw();
    } else if (e.touches.length === 2 && touchMode === "zoom") {
      const newDist = getDistance(e.touches[0], e.touches[1]);
      const zoom = newDist / lastTouchDistance;
      lastTouchDistance = newDist;

      // Midpoint for zoom center
      const rect = canvas.getBoundingClientRect();
      const mx = (e.touches[0].clientX + e.touches[1].clientX)/2 - rect.left;
      const my = (e.touches[0].clientY + e.touches[1].clientY)/2 - rect.top;


      imgX = mx - (mx - imgX) * zoom;
      imgY = my - (my - imgY) * zoom;
      scale *= zoom;
      scheduleDraw();
    }
  });

  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    touchDrag = false;
    if (touchMode === "point") {
      const touch = e.changedTouches[0];
      const ix = (touch.clientX - canvas.getBoundingClientRect().left - imgX) / scale;
      const iy = (touch.clientY - canvas.getBoundingClientRect().top - imgY) / scale;

      if (mode === "length" || mode === "radius") {
        if (!referencePoint1Selected) {
          referencePoints.x1 = ix;
          referencePoints.y1 = iy;
          referencePoint1Selected = true;
        } else if (!referencePoint2Selected) {
          referencePoints.x2 = ix;
          referencePoints.y2 = iy;

          const dux = referencePoints.x1 - referencePoints.x2;
          const duy = referencePoints.y1 - referencePoints.y2;
          unitLength =  Math.sqrt(sq(dux) + sq(duy));

          referencePoint2Selected = true;
          unitInputElement.style.display = 'block';
          resetButtonElement.style.display = 'block';
          document.getElementById("instruction").innerText = "Reference line length:";
        } else {
          if (mode === "length" && unitValueAvailable) {
            if (!linePoint1Selected) {
              linePoints.x1 = ix;
              linePoints.y1 = iy;
              linePoint1Selected = true;
              linePoint2Selected = false;
            } else if (!linePoint2Selected) {
              linePoints.x2 = ix;
              linePoints.y2 = iy;
              linePoint2Selected = true;
              linePoint1Selected = false;
              calculateLength();
            }
          }
          if (mode === "radius" && unitValueAvailable) {
            if (!circlePoint1Selected) {
              circlePoints.x1 = ix;
              circlePoints.y1 = iy;
              circlePoint1Selected = true;
              circlePoint2Selected = false;
              circlePoint3Selected = false;
            } else if (!circlePoint2Selected) {
              circlePoints.x2 = ix;
              circlePoints.y2 = iy;
              circlePoint2Selected = true;
            } else if (!circlePoint3Selected) {
              circlePoints.x3 = ix;
              circlePoints.y3 = iy;
              circlePoint3Selected = true;
              calculateCircleCenterAndRadius();
              circlePoint1Selected = false
            }
          }
        }
      }
      if (mode === "angle") {
        if (!anglePoint1Selected) {
          anglePoints.x1 = ix;
          anglePoints.y1 = iy;
          anglePoint1Selected = true;
          anglePoint2Selected = false;
          anglePoint3Selected = false;
        } else if (!anglePoint2Selected) {
          anglePoints.x2 = ix;
          anglePoints.y2 = iy;
          anglePoint2Selected = true;
        } else if (!anglePoint3Selected) {
          anglePoints.x3 = ix;
          anglePoints.y3 = iy;
          anglePoint3Selected = true;
          calculateAngle();
          anglePoint1Selected = false;
        }
      }
      scheduleDraw();
    }
  });

  // Optional: prevent page scrolling on touch
  document.body.addEventListener('touchmove', function(e) {
    if (e.target === canvas) {
      e.preventDefault();
    }
  }, {passive:false});


  canvas.addEventListener('contextmenu', e => {
    e.preventDefault(); // prevent the browser context menu
  });

  const calculateLength = () => {
    const dx = (linePoints.x1 - linePoints.x2);
    const dy = (linePoints.y1 - linePoints.y2);

    const length = unitInputElement.value * Math.sqrt(dx * dx + dy * dy) / unitLength;

    resultContainerElement.style.display = "block";
    resultLabelElement.innerHTML = "Length";
    resultValueElement.innerText = length.toFixed(4);
  }

  const calculateCircleCenterAndRadius = () => {
    let a1 = -2 * ( circlePoints.x1 - circlePoints.x2 );
    let b1 = -2 * ( circlePoints.y1 - circlePoints.y2 );
    let c1 = // x1^2 - x2^2 + y1^2 - y2^2
      sq(circlePoints.x1) - sq(circlePoints.x2)
      +
      sq(circlePoints.y1) - sq(circlePoints.y2);

    let a2 = -2 * ( circlePoints.x2 - circlePoints.x3 );
    let b2 = -2 * ( circlePoints.y2 - circlePoints.y3 );
    let c2 = // x2^2 - x3^2 + y2^2 - y3^2
      sq(circlePoints.x2) - sq(circlePoints.x3)
      +
      sq(circlePoints.y2) - sq(circlePoints.y3);

    circleCenterPoint.x = (b1*c2 - b2*c1) / (a1*b2 - a2*b1);
    circleCenterPoint.y = (c1*a2 - c2*a1) / (a1*b2 - a2*b1);

    // Radius
    circleRadius = Math.sqrt(sq(circleCenterPoint.x - circlePoints.x1) + sq(circleCenterPoint.y - circlePoints.y1));
    const circleRadiusToDisplay = unitInputElement.value * circleRadius / unitLength;

    resultContainerElement.style.display = "block";
    resultLabelElement.innerHTML = "Radius";
    resultValueElement.innerText = circleRadiusToDisplay.toFixed(4);
  }

  const calculateAngle = () => {
    let slopeAngle01 = slopeAngle(anglePoints.x1,anglePoints.y1,anglePoints.x2,anglePoints.y2);
    let slopeAngle12 = slopeAngle(anglePoints.x2,anglePoints.y2, anglePoints.x3,anglePoints.y3);

    angle = Math.abs(slopeAngle12 - slopeAngle01);

    angle = angle * 180 / 3.14159;

    if ( // c^2 < a^2 + b^2 [acute angle] (pythagoras)

      sq( distance(anglePoints.x1, anglePoints.y1, anglePoints.x3, anglePoints.y3) )
      <
      sq( distance(anglePoints.x1, anglePoints.y1, anglePoints.x2, anglePoints.y2) )
      +
      sq( distance(anglePoints.x2, anglePoints.y2, anglePoints.x3, anglePoints.y3) )
    )
    { // Then it is an Acute angle

      if (angle > 90)
        angle = 180 - angle; // Less than 90 degree
    }
    else
    { // Else it is an Obtuse angle

      if (angle < 90)
        angle = 180 - angle; // More than 90 degree
    }

    resultContainerElement.style.display = "block";
    resultLabelElement.innerHTML = "Angle";
    resultValueElement.innerText = angle.toFixed(4) + "Â°";
  }


let needsRedraw = false;

function scheduleDraw() {
  needsRedraw = true;
}

// Main draw loop
function drawLoop() {
  if (needsRedraw) {
    draw();
    needsRedraw = false;
  }
  requestAnimationFrame(drawLoop);
}
drawLoop();


  // Draw everything
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!imgLoaded) return;
    ctx.drawImage(img, imgX, imgY, img.width * scale, img.height * scale);

    if (referencePoint1Selected) {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.arc(imgX + referencePoints.x1 * scale, imgY + referencePoints.y1 * scale, 5, 0, Math.PI * 2);
      ctx.fill();

      if (!referencePoint2Selected) {
        ctx.strokeStyle= '#ff0';
        ctx.beginPath();
        ctx.moveTo(imgX + referencePoints.x1 * scale, imgY + referencePoints.y1 * scale);
        ctx.lineTo(mousePosition.x, mousePosition.y);
        ctx.stroke();
      }
    }
    if (referencePoint2Selected) {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.arc(imgX + referencePoints.x2 * scale, imgY + referencePoints.y2 * scale, 5, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#ff0';
      ctx.beginPath();
      ctx.moveTo(imgX + referencePoints.x1 * scale, imgY + referencePoints.y1 * scale);
      ctx.lineTo(imgX + referencePoints.x2 * scale, imgY + referencePoints.y2 * scale);
      ctx.stroke();
    }

    if (mode === "length") {
      if (linePoint1Selected || linePoint2Selected) {
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(imgX + linePoints.x1 * scale, imgY + linePoints.y1 * scale, 5, 0, Math.PI * 2);
        ctx.fill();

        if (!linePoint2Selected) {
          ctx.strokeStyle= '#ff0';
          ctx.beginPath();
          ctx.moveTo(imgX + linePoints.x1 * scale, imgY + linePoints.y1 * scale);
          ctx.lineTo(mousePosition.x, mousePosition.y);
          ctx.stroke();
        }
      }

      if (linePoint2Selected) {
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(imgX + linePoints.x2 * scale, imgY + linePoints.y2 * scale, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#ff0';
        ctx.beginPath();
        ctx.moveTo(imgX + linePoints.x1 * scale, imgY + linePoints.y1 * scale);
        ctx.lineTo(imgX + linePoints.x2 * scale, imgY + linePoints.y2 * scale);
        ctx.stroke();
      }
    }
    if (mode === "radius") {
      ctx.fillStyle = 'red';
      if (circlePoint1Selected || circlePoint3Selected) {
        ctx.beginPath();
        ctx.arc(imgX + circlePoints.x1 * scale, imgY + circlePoints.y1 * scale, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      if (circlePoint2Selected) {
        ctx.beginPath();
        ctx.arc(imgX + circlePoints.x2 * scale, imgY + circlePoints.y2 * scale, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      if (circlePoint3Selected) {
        ctx.beginPath();
        ctx.arc(imgX + circlePoints.x3 * scale, imgY + circlePoints.y3 * scale, 5, 0, Math.PI * 2);
        ctx.fill();

        //
        ctx.fillStyle = "#ff0";
        ctx.beginPath();
        ctx.arc(imgX + circleCenterPoint.x * scale, imgY + circleCenterPoint.y * scale, circleRadius * scale, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    if (mode === "angle") {
      if (anglePoint1Selected || anglePoint3Selected) {
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(imgX + anglePoints.x1 * scale, imgY + anglePoints.y1 * scale, 5, 0, Math.PI * 2);
        ctx.fill();

        if (!anglePoint2Selected) {
          ctx.strokeStyle= '#ff0';
          ctx.beginPath();
          ctx.moveTo(imgX + anglePoints.x1 * scale, imgY + anglePoints.y1 * scale);
          ctx.lineTo(mousePosition.x, mousePosition.y);
          ctx.stroke();
        }
      }

      if (anglePoint2Selected) {
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(imgX + anglePoints.x2 * scale, imgY + anglePoints.y2 * scale, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#ff0';
        ctx.beginPath();
        ctx.moveTo(imgX + anglePoints.x1 * scale, imgY + anglePoints.y1 * scale);
        ctx.lineTo(imgX + anglePoints.x2 * scale, imgY + anglePoints.y2 * scale);
        ctx.stroke();

        if (!anglePoint3Selected) {
          ctx.beginPath();
          ctx.moveTo(imgX + anglePoints.x2 * scale, imgY + anglePoints.y2 * scale);
          ctx.lineTo(mousePosition.x, mousePosition.y);
          ctx.stroke();
        }
      }

      if (anglePoint3Selected) {
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(imgX + anglePoints.x3 * scale, imgY + anglePoints.y3 * scale, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#ff0';
        ctx.beginPath();
        ctx.moveTo(imgX + anglePoints.x1 * scale, imgY + anglePoints.y1 * scale);
        ctx.lineTo(imgX + anglePoints.x2 * scale, imgY + anglePoints.y2 * scale);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(imgX + anglePoints.x2 * scale, imgY + anglePoints.y2 * scale);
        ctx.lineTo(imgX + anglePoints.x3 * scale, imgY + anglePoints.y3 * scale);
        ctx.stroke();
      }
    }
  }

  function redrawReferenceLine() {
    reset();
    document.getElementById("instruction").innerText = DRAW_REF_LINE_INST;
    scheduleDraw();
  };
  function reset() {
    referencePoint1Selected = false;
    referencePoint2Selected = false;
    resetLength();
    resetRadius();
    resetAngle();
    unitInputElement.style.display = 'none';
    resetButtonElement.style.display = 'none';
    resultValueElement.innerText = '';
    resultContainerElement.style.display = 'none';
  };
  function resetLength() {
    linePoint1Selected = false;
    linePoint2Selected = false;
  };
  function resetRadius() {
    circlePoint1Selected = false;
    circlePoint2Selected = false;
    circlePoint3Selected = false;
  };
  function resetAngle() {
    anglePoint1Selected = false;
    anglePoint2Selected = false;
    anglePoint3Selected = false;
  };
  const sq = n => n*n;
  const distance = (x1, y1, x2, y2) => {
    return Math.sqrt(sq(x1-x2) + sq(y1-y2));
  };
  const slopeAngle = (x1, y1, x2, y2) => {
    if (x1 - x2 === 0)
      return Math.PI/2;
    else
      return Math.atan( (y1-y2) / (x1-x2) );
  };
</script>

</body>

</html>
