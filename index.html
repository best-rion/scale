<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>SCALE</title>
  <style>
    /* Base */

    body {
      margin: 0;
      padding: 20px;
      font-family: system-ui, -apple-system, Segoe UI, sans-serif;
      background: #f2f2f2;
      color: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* Header split */

    .header {
      width: 800px;
      height: 100px;
      display: flex;
      gap: 24px;
      margin-bottom: 10px;
    }

    /* Columns */

    .header-left,
    .header-right {
      flex: 1;
    }

    /* Stack elements vertically */

    .left,
    .right {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    /* Inputs & buttons */

    input[type="file"],
    input[type="number"],
    button {
      font-size: 14px;
      padding: 6px 10px;
      border: 1px solid #bbb;
      border-radius: 4px;
      background: #fff;
      color: #222;
    }

    input[type="number"] {
      width: auto;
    }

    button {
      cursor: pointer;
    }

    button:hover {
      background: #eaeaea;
    }

    /* Mode buttons */

    #modeButton-container {
      display: flex;
      gap: 6px;
    }

    .modeButton {
      min-width: 80px;
    }

    /* Instruction */

    #instruction {
      margin: 0;
      font-size: 24px;
      color: #555;
      min-height: 18px; /* prevents layout jump */
    }

    /* Result */

    #result-container {
      font-size: 15px;
      font-weight: 500;
      min-height: 20px;
    }

    #result-label {
      color: #555;
    }

    /* Canvas */

    canvas {
      margin-top: 12px;
      border: 1px solid #888;
      background: #fff;
      cursor: crosshair;
    }

  </style>
</head>

<body>
<div class="header">
  <div class="header-left">
    <div class="left">
      <input type="file" id="imgUpload" accept="image/*">
      <div id="modeButton-container" style="display: none">
        <button class="modeButton" id="length" onclick="setLengthMode()">Length</button>
        <button class="modeButton" id="radius" onclick="setRadiusMode()">Radius</button>
        <button class="modeButton" id="angle" onclick="setAngleMode()">Angle</button>
      </div>
    </div>

    <p id="result-container" style="display: none;">
      <span id="result-label"></span>: <span id="result-value"></span>
    </p>
  </div>

  <div class="header-right">
    <div class="right">
      <p id="instruction"></p>
      <input type="number" id="unit"
             placeholder="length of the reference line"
             style="display: none">
      <button id="reset-button"
              onclick="reset()"
              style="display: none">
        Reset
      </button>
    </div>
  </div>
</div>

<canvas id="canvas" width="800" height="600"></canvas>

<script>
  const canvas = document.getElementById('canvas');
  const unitInputElement = document.getElementById('unit');
  unitInputElement.value = null;
  unitInputElement.addEventListener('input', () => {
    unitValueUpdate();
  })
  const resetButtonElement = document.getElementById('reset-button');
  const resultValueElement = document.getElementById('result-value');
  const resultLabelElement = document.getElementById('result-label');
  const resultContainerElement = document.getElementById('result-container');
  const instructionElement = document.getElementById('instruction');

  const DRAW_REF_LINE_INST = "Draw Reference Line";
  const REF_INPUT_LABEL = "Reference Line Length:";
  const COLORS = {
    ref: '#0f0',
    measure: '#f00',
    preview: '#0ff'
  };


  let mode; // length | radius | angle
  let unitValueAvailable = false;
  let mousePosition = { x: 0, y: 0 };
  let needsRedraw = false;

  const ctx = canvas.getContext('2d');
  let img = new Image();
  let imgLoaded = false;

  // Image state
  let imgX = 0, imgY = 0;
  let scale = 1;
  let dragging = false;
  let dragStart = { x: 0, y: 0 };

  // For unit
  let referencePoint1Selected = false;
  let referencePoint2Selected = false;
  let referencePoints = {x1: 0, y1: 0, x2: 0, y2: 0};
  let unitLength = 0;

  // For line
  let linePoint1Selected = false;
  let linePoint2Selected = false;
  let linePoints = {x1: 0, y1: 0, x2: 0, y2: 0};

  // For curvature
  let circlePoint1Selected = false;
  let circlePoint2Selected = false;
  let circlePoint3Selected = false;
  let circlePoints = {x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0};
  let circleCenterPoint = {x: 0, y: 0};
  let circleRadius = 0;

  // For angle
  let anglePoint1Selected = false;
  let anglePoint2Selected = false;
  let anglePoint3Selected = false;
  let anglePoints = {x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0};

  const setLengthMode = () => {
    mode = "length";
    document.getElementById("length").style.color = "red";
    document.getElementById("radius").style.color = "black";
    document.getElementById("angle").style.color = "black";
    showDrawInstruction();
    resetRadius();
    resetAngle();
    scheduleDraw();
  }
  const setRadiusMode = () => {
    mode = "radius";
    document.getElementById("length").style.color = "black";
    document.getElementById("radius").style.color = "red";
    document.getElementById("angle").style.color = "black";
    showDrawInstruction();
    resetLength();
    resetAngle();
    scheduleDraw();
  }
  const setAngleMode = () => {
    mode = "angle";
    document.getElementById("length").style.color = "black";
    document.getElementById("radius").style.color = "black";
    document.getElementById("angle").style.color = "red";
    showDrawInstruction();
    resetLength();
    resetRadius();
    if (referencePoint1Selected && !referencePoint2Selected) {
      referencePoint1Selected = false;
    }
    scheduleDraw();
  }
  const showDrawInstruction = () => {
    if (!referencePoint2Selected) {
      if (mode === "length" || mode === "radius") {
        instructionElement.innerText = DRAW_REF_LINE_INST;
      } else {
        instructionElement.innerText = "";
      }
    }
  }
  const recalculate = () => {
    if (mode === "length" && linePoint2Selected) {
      calculateLength();
    }
    if (mode === "radius" && circlePoint3Selected) {
      calculateCircleCenterAndRadius();
    }
  }

  function unitValueUpdate() {
    const unitValue = unitInputElement.value;
    if (isNaN(unitValue) || unitValue === "" || unitValue <= 0) {
      instructionElement.innerText = "Type a +ve number";
      unitValueAvailable = false;
    } else {
      instructionElement.innerText = REF_INPUT_LABEL;
      unitValueAvailable = true;
      recalculate();
    }
  }

  // Handle image upload
  document.getElementById('imgUpload').addEventListener('change', e => {
    const file = e.target.files[0];
    if (file) {
      img.src = URL.createObjectURL(file);
      img.onload = () => {
        imgLoaded = true;
        document.getElementById("modeButton-container").style.display = "flex";
        reset();

        imgX = canvas.width / 2 - img.width / 2;
        imgY = canvas.height / 2 - img.height / 2;
        scheduleDraw();
      };
    }
  });

  // Zoom
  canvas.addEventListener('wheel', e => {
    if (!imgLoaded) return;
    const zoom = e.deltaY < 0 ? 1.1 : 0.9;
    // Zoom relative to mouse
    const mx = e.offsetX;
    const my = e.offsetY;
    imgX = mx - (mx - imgX) * zoom;
    imgY = my - (my - imgY) * zoom;
    scale *= zoom;
    scheduleDraw();
  });

  // Drag image
  canvas.addEventListener('mousedown', e => {
    if (e.button === 2) {
      dragging = true;
      dragStart.x = e.offsetX - imgX;
      dragStart.y = e.offsetY - imgY;
    } else {
      dragging = false;
    }
  });
  canvas.addEventListener('mousemove', e => {
    if (! imgLoaded) return;
    if (dragging) {
      imgX = e.offsetX - dragStart.x;
      imgY = e.offsetY - dragStart.y;
    }
    if (dragging || referencePoint1Selected || linePoint1Selected || anglePoint1Selected) {
      mousePosition.x = e.offsetX;
      mousePosition.y = e.offsetY;
      scheduleDraw();
    }
  });
  canvas.addEventListener('mouseup', e => dragging = false);
  canvas.addEventListener('mouseleave', e => dragging = false);

  canvas.addEventListener('contextmenu', e => {
    e.preventDefault(); // prevent the browser context menu
  });

  const calculateLength = () => {
    const dx = (linePoints.x1 - linePoints.x2);
    const dy = (linePoints.y1 - linePoints.y2);

    const length = unitInputElement.value * Math.sqrt(dx * dx + dy * dy) / unitLength;

    resultContainerElement.style.display = "block";
    resultLabelElement.innerHTML = "Length";
    resultValueElement.innerText = length.toFixed(4);
  }

  const calculateCircleCenterAndRadius = () => {
    let a1 = -2 * ( circlePoints.x1 - circlePoints.x2 );
    let b1 = -2 * ( circlePoints.y1 - circlePoints.y2 );
    let c1 = // x1^2 - x2^2 + y1^2 - y2^2
      sq(circlePoints.x1) - sq(circlePoints.x2)
      +
      sq(circlePoints.y1) - sq(circlePoints.y2);

    let a2 = -2 * ( circlePoints.x2 - circlePoints.x3 );
    let b2 = -2 * ( circlePoints.y2 - circlePoints.y3 );
    let c2 = // x2^2 - x3^2 + y2^2 - y3^2
      sq(circlePoints.x2) - sq(circlePoints.x3)
      +
      sq(circlePoints.y2) - sq(circlePoints.y3);

    circleCenterPoint.x = (b1*c2 - b2*c1) / (a1*b2 - a2*b1);
    circleCenterPoint.y = (c1*a2 - c2*a1) / (a1*b2 - a2*b1);

    // Radius
    circleRadius = Math.sqrt(sq(circleCenterPoint.x - circlePoints.x1) + sq(circleCenterPoint.y - circlePoints.y1));
    const circleRadiusToDisplay = unitInputElement.value * circleRadius / unitLength;

    resultContainerElement.style.display = "block";
    resultLabelElement.innerHTML = "Radius";
    resultValueElement.innerText = circleRadiusToDisplay.toFixed(4);
  }

  function calculateAngle() {
    const v1x = anglePoints.x1 - anglePoints.x2;
    const v1y = anglePoints.y1 - anglePoints.y2;
    const v2x = anglePoints.x3 - anglePoints.x2;
    const v2y = anglePoints.y3 - anglePoints.y2;

    const mag1 = Math.hypot(v1x, v1y);
    const mag2 = Math.hypot(v2x, v2y);

    // Edge case: overlapping points
    if (mag1 === 0 || mag2 === 0) {
      resultValueElement.innerText = "Invalid angle";
      return;
    }

    let cos = (v1x*v2x + v1y*v2y) / (mag1 * mag2);

    // Clamp to avoid NaN from floating error
    cos = Math.min(1, Math.max(-1, cos));

    const angle = Math.acos(cos) * 180 / Math.PI;

    resultContainerElement.style.display = "block";
    resultLabelElement.innerHTML = "Angle";
    resultValueElement.innerText = angle.toFixed(4) + "Â°";
  }

  // Add points
  canvas.addEventListener('click', e => {
    if (!imgLoaded) return;
    // Ignore if dragging
    if (dragging) return;

    if (e.button === 0) {
      let ix = (e.offsetX - imgX) / scale;
      let iy = (e.offsetY - imgY) / scale;
      if (mode === "length" || mode === "radius") {
        if (!referencePoint1Selected) {
          referencePoints.x1 = ix;
          referencePoints.y1 = iy;
          referencePoint1Selected = true;
        } else if (!referencePoint2Selected) {
          referencePoints.x2 = ix;
          referencePoints.y2 = iy;

          const dux = referencePoints.x1 - referencePoints.x2;
          const duy = referencePoints.y1 - referencePoints.y2;
          unitLength =  Math.sqrt(sq(dux) + sq(duy));

          referencePoint2Selected = true;
          unitInputElement.style.display = 'block';
          unitInputElement.value = 1;
          unitValueAvailable = true;
          resetButtonElement.style.display = 'block';
          instructionElement.innerText = REF_INPUT_LABEL;
        } else {
          if (mode === "length" && unitValueAvailable) {
            if (!linePoint1Selected) {
              linePoints.x1 = ix;
              linePoints.y1 = iy;
              linePoint1Selected = true;
              linePoint2Selected = false;
            } else if (!linePoint2Selected) {
              linePoints.x2 = ix;
              linePoints.y2 = iy;
              linePoint2Selected = true;
              linePoint1Selected = false;
              calculateLength();
            }
          }
          if (mode === "radius" && unitValueAvailable) {
            if (!circlePoint1Selected) {
              circlePoints.x1 = ix;
              circlePoints.y1 = iy;
              circlePoint1Selected = true;
              circlePoint2Selected = false;
              circlePoint3Selected = false;
            } else if (!circlePoint2Selected) {
              circlePoints.x2 = ix;
              circlePoints.y2 = iy;
              circlePoint2Selected = true;
            } else if (!circlePoint3Selected) {
              circlePoints.x3 = ix;
              circlePoints.y3 = iy;
              circlePoint3Selected = true;
              calculateCircleCenterAndRadius();
              circlePoint1Selected = false
            }
          }
        }
      }
      if (mode === "angle") {
        if (!anglePoint1Selected) {
          anglePoints.x1 = (e.offsetX - imgX) / scale;
          anglePoints.y1 = (e.offsetY - imgY) / scale;
          anglePoint1Selected = true;
          anglePoint2Selected = false;
          anglePoint3Selected = false;
        } else if (!anglePoint2Selected) {
          anglePoints.x2 = (e.offsetX - imgX) / scale;
          anglePoints.y2 = (e.offsetY - imgY) / scale;
          anglePoint2Selected = true;
        } else if (!anglePoint3Selected) {
          anglePoints.x3 = (e.offsetX - imgX) / scale;
          anglePoints.y3 = (e.offsetY - imgY) / scale;
          anglePoint3Selected = true;
          calculateAngle();
          anglePoint1Selected = false;
        }
      }
      scheduleDraw();
    }
  });

  function scheduleDraw() {
    needsRedraw = true;
  }

  // Main draw loop
  function drawLoop() {
    if (needsRedraw) {
      draw();
      needsRedraw = false;
    }
    requestAnimationFrame(drawLoop);
  }
  drawLoop();

  // Draw everything
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!imgLoaded) return;
    ctx.drawImage(img, imgX, imgY, img.width * scale, img.height * scale);

    if (referencePoint1Selected) {
      ctx.fillStyle = COLORS.ref;
      ctx.beginPath();
      ctx.arc(imgX + referencePoints.x1 * scale, imgY + referencePoints.y1 * scale, 5, 0, Math.PI * 2);
      ctx.fill();

      if (!referencePoint2Selected) {
        ctx.strokeStyle= COLORS.preview;
        ctx.beginPath();
        ctx.moveTo(imgX + referencePoints.x1 * scale, imgY + referencePoints.y1 * scale);
        ctx.lineTo(mousePosition.x, mousePosition.y);
        ctx.stroke();
      }
    }
    if (referencePoint2Selected) {
      ctx.fillStyle = COLORS.ref;
      ctx.beginPath();
      ctx.arc(imgX + referencePoints.x2 * scale, imgY + referencePoints.y2 * scale, 5, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = COLORS.preview;
      ctx.beginPath();
      ctx.moveTo(imgX + referencePoints.x1 * scale, imgY + referencePoints.y1 * scale);
      ctx.lineTo(imgX + referencePoints.x2 * scale, imgY + referencePoints.y2 * scale);
      ctx.stroke();
    }

    if (mode === "length") {
      if (linePoint1Selected || linePoint2Selected) {
        ctx.fillStyle = COLORS.measure;
        ctx.beginPath();
        ctx.arc(imgX + linePoints.x1 * scale, imgY + linePoints.y1 * scale, 5, 0, Math.PI * 2);
        ctx.fill();

        if (!linePoint2Selected) {
          ctx.strokeStyle= COLORS.preview;
          ctx.beginPath();
          ctx.moveTo(imgX + linePoints.x1 * scale, imgY + linePoints.y1 * scale);
          ctx.lineTo(mousePosition.x, mousePosition.y);
          ctx.stroke();
        }
      }

      if (linePoint2Selected) {
        ctx.fillStyle = COLORS.measure;
        ctx.beginPath();
        ctx.arc(imgX + linePoints.x2 * scale, imgY + linePoints.y2 * scale, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = COLORS.preview;
        ctx.beginPath();
        ctx.moveTo(imgX + linePoints.x1 * scale, imgY + linePoints.y1 * scale);
        ctx.lineTo(imgX + linePoints.x2 * scale, imgY + linePoints.y2 * scale);
        ctx.stroke();
      }
    }
    if (mode === "radius") {
      ctx.fillStyle = COLORS.measure;
      if (circlePoint1Selected || circlePoint3Selected) {
        ctx.beginPath();
        ctx.arc(imgX + circlePoints.x1 * scale, imgY + circlePoints.y1 * scale, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      if (circlePoint2Selected) {
        ctx.beginPath();
        ctx.arc(imgX + circlePoints.x2 * scale, imgY + circlePoints.y2 * scale, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      if (circlePoint3Selected) {
        ctx.beginPath();
        ctx.arc(imgX + circlePoints.x3 * scale, imgY + circlePoints.y3 * scale, 5, 0, Math.PI * 2);
        ctx.fill();

        //
        ctx.fillStyle = "#ff0";
        ctx.beginPath();
        ctx.arc(imgX + circleCenterPoint.x * scale, imgY + circleCenterPoint.y * scale, circleRadius * scale, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    if (mode === "angle") {
      if (anglePoint1Selected || anglePoint3Selected) {
        ctx.fillStyle = COLORS.measure;
        ctx.beginPath();
        ctx.arc(imgX + anglePoints.x1 * scale, imgY + anglePoints.y1 * scale, 5, 0, Math.PI * 2);
        ctx.fill();

        if (!anglePoint2Selected) {
          ctx.strokeStyle= COLORS.preview;
          ctx.beginPath();
          ctx.moveTo(imgX + anglePoints.x1 * scale, imgY + anglePoints.y1 * scale);
          ctx.lineTo(mousePosition.x, mousePosition.y);
          ctx.stroke();
        }
      }

      if (anglePoint2Selected) {
        ctx.fillStyle = COLORS.measure;
        ctx.beginPath();
        ctx.arc(imgX + anglePoints.x2 * scale, imgY + anglePoints.y2 * scale, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = COLORS.preview;
        ctx.beginPath();
        ctx.moveTo(imgX + anglePoints.x1 * scale, imgY + anglePoints.y1 * scale);
        ctx.lineTo(imgX + anglePoints.x2 * scale, imgY + anglePoints.y2 * scale);
        ctx.stroke();

        if (!anglePoint3Selected) {
          ctx.beginPath();
          ctx.moveTo(imgX + anglePoints.x2 * scale, imgY + anglePoints.y2 * scale);
          ctx.lineTo(mousePosition.x, mousePosition.y);
          ctx.stroke();
        }
      }

      if (anglePoint3Selected) {
        ctx.fillStyle = COLORS.measure;
        ctx.beginPath();
        ctx.arc(imgX + anglePoints.x3 * scale, imgY + anglePoints.y3 * scale, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = COLORS.preview;
        ctx.beginPath();
        ctx.moveTo(imgX + anglePoints.x1 * scale, imgY + anglePoints.y1 * scale);
        ctx.lineTo(imgX + anglePoints.x2 * scale, imgY + anglePoints.y2 * scale);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(imgX + anglePoints.x2 * scale, imgY + anglePoints.y2 * scale);
        ctx.lineTo(imgX + anglePoints.x3 * scale, imgY + anglePoints.y3 * scale);
        ctx.stroke();
      }
    }
  }

  function reset() {
    referencePoint1Selected = false;
    referencePoint2Selected = false;
    resetLength();
    resetRadius();
    resetAngle();
    unitInputElement.value = '';
    unitInputElement.style.display = 'none';
    resetButtonElement.style.display = 'none';
    resultValueElement.innerText = '';
    resultContainerElement.style.display = 'none';
    instructionElement.innerText = (mode === "length" || mode === "radius") ? DRAW_REF_LINE_INST : "";
    scheduleDraw();
  };
  function resetLength() {
    linePoint1Selected = false;
    linePoint2Selected = false;
  };
  function resetRadius() {
    circlePoint1Selected = false;
    circlePoint2Selected = false;
    circlePoint3Selected = false;
  };
  function resetAngle() {
    anglePoint1Selected = false;
    anglePoint2Selected = false;
    anglePoint3Selected = false;
  };
  const sq = n => n*n;
  const distance = (x1, y1, x2, y2) => {
    return Math.sqrt(sq(x1-x2) + sq(y1-y2));
  };
  const slopeAngle = (x1, y1, x2, y2) => {
    if (x1 - x2 === 0)
      return Math.PI/2;
    else
      return Math.atan( (y1-y2) / (x1-x2) );
  };
</script>

</body>

</html>
